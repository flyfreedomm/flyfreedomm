import requests
import json
import os
import time
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional

class Vulnerability:
    def __init__(self, name: str, severity: str, description: str, cvss_score: float, 
                 affected_software: str, affected_version: str, published_date: str):
        self.name = name
        self.severity = severity
        self.description = description
        self.cvss_score = cvss_score
        self.affected_software = affected_software
        self.affected_version = affected_version
        self.published_date = published_date

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "severity": self.severity,
            "description": self.description,
            "cvss_score": self.cvss_score,
            "affected_software": self.affected_software,
            "affected_version": self.affected_version,
            "published_date": self.published_date
        }

class VulnerabilityScanner:
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        }
        if api_key:
            self.headers['apiKey'] = api_key
            
        self.logger = self._setup_logger()
        self.reports_dir = Path("vulnerability_reports")
        self.reports_dir.mkdir(exist_ok=True)
        
        # 漏洞严重程度映射
        self.severity_map = {
            "CRITICAL": 4,
            "HIGH": 3,
            "MEDIUM": 2,
            "LOW": 1,
            "INFO": 0
        }

    def _setup_logger(self) -> logging.Logger:
        logger = logging.getLogger("vulnerability_scanner")
        logger.setLevel(logging.INFO)
        
        # 创建文件处理器
        file_handler = logging.FileHandler("scanner.log")
        file_handler.setLevel(logging.INFO)
        
        # 创建控制台处理器
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # 创建格式化器并添加到处理器
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        # 添加处理器到logger
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger

    def search_nvd(self, keyword: str, limit: int = 50) -> List[Vulnerability]:
        """搜索NVD数据库获取漏洞信息"""
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        params = {
            "keywordSearch": keyword,
            "resultsPerPage": limit
        }
        
        try:
            response = requests.get(base_url, headers=self.headers, params=params)
            response.raise_for_status()
            data = response.json()
            
            vulnerabilities = []
            for item in data.get('vulnerabilities', []):
                cve = item.get('cve', {})
                name = cve.get('id', 'Unknown')
                
                # 获取严重程度和CVSS分数
                metrics = cve.get('metrics', {})
                cvss_data = metrics.get('cvssMetricV31', [{}])[0].get('cvssData', {})
                cvss_score = cvss_data.get('baseScore', 0.0)
                
                # 确定严重程度
                severity = "LOW"
                if cvss_score >= 9.0:
                    severity = "CRITICAL"
                elif cvss_score >= 7.0:
                    severity = "HIGH"
                elif cvss_score >= 4.0:
                    severity = "MEDIUM"
                
                # 获取描述
                descriptions = cve.get('descriptions', [{}])
                description = descriptions[0].get('value', 'No description available')
                
                # 获取受影响的软件和版本
                configurations = cve.get('configurations', [{}])
                nodes = configurations[0].get('nodes', [{}])
                cpe_match = nodes[0].get('cpeMatch', [{}])[0]
                cpe_uri = cpe_match.get('cpe23Uri', '')
                
                # 解析CPE URI获取软件和版本
                cpe_parts = cpe_uri.split(':')
                affected_software = cpe_parts[3] if len(cpe_parts) > 3 else 'Unknown'
                affected_version = cpe_parts[4] if len(cpe_parts) > 4 else 'Unknown'
                
                # 获取发布日期
                published_date = cve.get('published', 'Unknown')
                
                vulnerabilities.append(Vulnerability(
                    name, severity, description, cvss_score, 
                    affected_software, affected_version, published_date
                ))
            
            return vulnerabilities
            
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error searching NVD: {e}")
            return []

    def analyze_and_sort(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """根据严重程度对漏洞进行分析和排序"""
        return sorted(
            vulnerabilities, 
            key=lambda v: (self.severity_map.get(v.severity, 0), v.cvss_score),
            reverse=True
        )

    def generate_report(self, vulnerabilities: List[Vulnerability], software_name: str) -> str:
        """生成漏洞报告"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = self.reports_dir / f"{software_name}_vulnerabilities_{timestamp}.json"
        
        report_data = {
            "scan_timestamp": timestamp,
            "software_name": software_name,
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": [v.to_dict() for v in vulnerabilities]
        }
        
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, ensure_ascii=False, indent=4)
            self.logger.info(f"Report generated: {report_file}")
            return str(report_file)
        except Exception as e:
            self.logger.error(f"Error generating report: {e}")
            return ""

    def scan_software(self, software_name: str, version: Optional[str] = None) -> None:
        """扫描特定软件的漏洞"""
        self.logger.info(f"Scanning for vulnerabilities in {software_name} {version or ''}")
        
        # 构建搜索关键词
        keyword = software_name
        if version:
            keyword += f" {version}"
        
        # 搜索漏洞
        vulnerabilities = self.search_nvd(keyword)
        self.logger.info(f"Found {len(vulnerabilities)} potential vulnerabilities")
        
        # 分析和排序漏洞
        sorted_vulnerabilities = self.analyze_and_sort(vulnerabilities)
        
        # 生成报告
        report_path = self.generate_report(sorted_vulnerabilities, software_name)
        if report_path:
            self.logger.info(f"Successfully generated report at {report_path}")
        else:
            self.logger.error("Failed to generate report")

    def scan_websites(self, urls: List[str]) -> None:
        """扫描网站的漏洞"""
        # 注意：此方法仅作为框架提供，实际网站扫描需要更复杂的实现
        # 通常需要使用专门的扫描工具如Nmap、OWASP ZAP等
        
        self.logger.info(f"Scanning {len(urls)} websites for vulnerabilities")
        
        for url in urls:
            self.logger.info(f"Scanning website: {url}")
            
            # 模拟网站扫描过程
            # 在实际应用中，这里应该调用专门的网站扫描API或工具
            time.sleep(1)  # 模拟扫描时间
            
            # 模拟发现的漏洞
            mock_vulnerabilities = [
                Vulnerability(
                    "Mock Vulnerability",
                    "MEDIUM",
                    "This is a mock vulnerability for demonstration purposes",
                    5.5,
                    url,
                    "N/A",
                    datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                )
            ]
            
            # 分析和排序漏洞
            sorted_vulnerabilities = self.analyze_and_sort(mock_vulnerabilities)
            
            # 生成报告
            software_name = url.replace('https://', '').replace('http://', '').split('/')[0]
            report_path = self.generate_report(sorted_vulnerabilities, software_name)
            
            if report_path:
                self.logger.info(f"Successfully generated report for {url} at {report_path}")
            else:
                self.logger.error(f"Failed to generate report for {url}")

def main():
    # 创建漏洞扫描器实例
    # 如果有NVD API密钥，可以在这里提供
    scanner = VulnerabilityScanner()
    
    # 扫描特定软件
    scanner.scan_software("nginx", "1.18.0")
    scanner.scan_software("openssl", "1.1.1")
    
    # 扫描网站
    websites_to_scan = [
        "https://example.com",
        "https://testwebsite.com"
    ]
    scanner.scan_websites(websites_to_scan)

if __name__ == "__main__":
    main()    